module MOM_wave_structure
!***********************************************************************
!*                   GNU General Public License                        *
!* This file is a part of MOM.                                         *
!*                                                                     *
!* MOM is free software; you can redistribute it and/or modify it and  *
!* are expected to follow the terms of the GNU General Public License  *
!* as published by the Free Software Foundation; either version 2 of   *
!* the License, or (at your option) any later version.                 *
!*                                                                     *
!* MOM is distributed in the hope that it will be useful, but WITHOUT  *
!* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY  *
!* or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    *
!* License for more details.                                           *
!*                                                                     *
!* For the full text of the GNU General Public License,                *
!* write to: Free Software Foundation, Inc.,                           *
!*           675 Mass Ave, Cambridge, MA 02139, USA.                   *
!* or see:   http://www.gnu.org/licenses/gpl.html                      *
!***********************************************************************
!
!********+*********+*********+*********+*********+*********+*********+**
!*                                                                     *
!*  By Ben Mater, September, 2015                                      *
!*                                                                     *
!*    The subroutine in this module calculates the vertical structure  *
!*    functions of the first baroclinic mode internal wave speed.      *
!*                                                                     *
!*  Macros written all in capital letters are defined in MOM_memory.h. *
!*                                                                     *
!*     A small fragment of the grid is shown below:                    *
!*                                                                     *
!*    j+1  x ^ x ^ x   At x:  q                                        *
!*    j+1  > o > o >   At ^:  v, vh, vav                               *
!*    j    x ^ x ^ x   At >:  u, uh, uav                               *
!*    j    > o > o >   At o:  h                                        *
!*    j-1  x ^ x ^ x                                                   *
!*        i-1  i  i+1  At x & ^:                                       *
!*           i  i+1    At > & o:                                       *
!*                                                                     *
!*  The boundaries always run through q grid points (x).               *
!*                                                                     *
!********+*********+*********+*********+*********+*********+*********+**

!use MOM_diag_mediator, only : post_data, query_averaging_enabled, diag_ctrl
!use MOM_diag_mediator, only : register_diag_field, safe_alloc_ptr, time_type
!use MOM_error_handler, only : MOM_error, FATAL, WARNING
!use MOM_file_parser, only : log_version, param_file_type
use MOM_grid, only : ocean_grid_type

implicit none ; private

#include <MOM_memory.h>

public wave_structure, wave_structure_init

type, public :: wave_structure_CS ; private
  type(diag_ctrl), pointer :: diag ! A structure that is used to regulate the
                                   ! timing of diagnostic output. 
end type wave_structure_CS

contains

subroutine wave_structure(h, tv, G, cg1, full_halos=.true., w_strct, u_strct, z_depth, N2, num_intfaces)
  real, dimension(NIMEM_,NJMEM_,NKMEM_), intent(in)  :: h
  type(thermo_var_ptrs),                 intent(in)  :: tv
  real, dimension(NIMEM_,NJMEM_),        intent(in)  :: cg1
  type(ocean_grid_type),                 intent(in)  :: G
  type(wave_structure_CS), optional,     pointer     :: CS
  logical,                 optional,     intent(in)  :: full_halos
  real, dimension(NIMEM_,NJMEM_,NKMEM_), intent(out) :: w_strct, u_strct, depths
  real, dimension(NIMEM_,NJMEM_),        intent(out) :: num_intfaces
!    This subroutine determines the first mode internal wave velocity structure.
! Arguments: 
!  (in)      cg1 - The first mode internal gravity wave speed, in m s-1.
!  (in)      G - The ocean's grid structure.
!  (out)     w_strct - Vertical structure of vertical velocity (normalized), in m s-1.
!  (out)     u_strct - Vertical structure of horizontal velocity (normalized), in m s-1.
!  (out)     depths - Depths of layer interfaces, in m.
!  (out)     num_intfaces - Number of layer interfaces (including surface and bottom)
!
! This subroutine solves for the eigen vector [vertical structure, e(k)] associated with 
! the first baroclinic mode speed [i.e., smallest eigen value (lam = 1/c^2)] of the 
! system d2e/dz2 = -(N2/cn2)e, or (A-lam*I)e = 0, where A = -(1/N2)(d2/dz2), lam = 1/c^2,
! and I is the identity matrix. 2nd order discretization in the vertical lets this system
! be represented as 
!
!   -Igu(k)*e(k-1) + (Igu(k)+Igl(k)-lam)*e(k) - Igl(k)*e(k+1) = 0.0
!
! with rigid lid boundary conditions e(1) = e(nz+1) = 0.0 giving
!
!   (Igu(2)+Igl(2)-lam)*e(2) - Igl(2)*e(3) = 0.0
!   -Igu(nz)*e(nz-1) + (Igu(nz)+Igl(nz)-lam)*e(nz) = 0.0
!
! where, upon noting N2 = reduced gravity/layer thickness, we get
!    Igl(k) = 1.0/(gprime(k)*H(k)) ; Igu(k) = 1.0/(gprime(k)*H(k-1))
!
! The eigen value for this system is approximated using "wave_speed." This subroutine uses 
! these eigen values (mode speeds) to estimate the corresponding eigen vectors (velocity
! structure) using the "inverse iteration with shift" method. The algorithm is 
! 
!   Pick a starting vector reasonably close to mode structure and with unit magnitude, b_guess
!   For n=1,2,3,...
!     Solve (A-lam*I)e = e_guess for e
!     Set e_guess=e/|e| and repeat, with each iteration refining the estimate of e

  real, dimension(SZK_(G)+1) :: &
    dRho_dT, dRho_dS, &
    pres, T_int, S_int, &
    gprime        ! The reduced gravity across each interface, in m s-2.
  real, dimension(SZK_(G)) :: &
    Igl, Igu      ! The inverse of the reduced gravity across an interface times
                  ! the thickness of the layer below (Igl) or above (Igu) it,
                  ! in units of s2 m-2.
  real, dimension(SZK_(G),SZI_(G)) :: &
    Hf, Tf, Sf, Rf
  real, dimension(SZK_(G)) :: &
    Hc, Tc, Sc, Rc, &
    det, ddet
  real :: lam, dlam, lam0
  real :: min_h_frac
  real :: H_to_pres
  real, dimension(SZI_(G)) :: &
    htot, hmin, &  ! Thicknesses in m.
    H_here, HxT_here, HxS_here, HxR_here
  real :: speed2_tot
  real :: I_Hnew, drxh_sum
  real, parameter :: tol1  = 0.0001, tol2 = 0.001
  real, pointer, dimension(:,:,:) :: T, S
  real :: g_Rho0  ! G_Earth/Rho0 in m4 s-2 kg-1.
  real :: rescale, I_rescale
  integer :: kf(SZI_(G))
  integer, parameter :: max_itt = 10
  logical :: use_EOS    ! If true, density is calculated from T & S using an
                        ! equation of state.
                        
  real, dimension(:) :: e_guess, e_itt ! temporary vectors for TDMA
  integer :: kc
  integer :: i, j, k, k2, itt, is, ie, js, je, nz

  is = G%isc ; ie = G%iec ; js = G%jsc ; je = G%jec ; nz = G%ke
  
  if (present(CS)) then
    if (.not. associated(CS)) call MOM_error(FATAL, "MOM_wave_structure: "// &
           "Module must be initialized before it is used.")
  endif
  if (present(full_halos)) then ; if (full_halos) then
    is = G%isd ; ie = G%ied ; js = G%jsd ; je = G%jed
  endif ; endif
  
  w_strct(:,:,:) = 0.0
  
  S => tv%S ; T => tv%T
  g_Rho0 = G%g_Earth/G%Rho0
  use_EOS = associated(tv%eqn_of_state)

  H_to_pres = G%g_Earth * G%Rho0
  rescale = 1024.0**4 ; I_rescale = 1.0/rescale

  min_h_frac = tol1 / real(nz)
!$OMP parallel do default(none) shared(is,ie,js,je,nz,h,G,min_h_frac,use_EOS,T,S,      &
!$OMP                                  H_to_pres,tv,cg1,g_Rho0,rescale,I_rescale)      &
!$OMP                          private(htot,hmin,kf,H_here,HxT_here,HxS_here,HxR_here, &
!$OMP                                  Hf,Tf,Sf,Rf,pres,T_int,S_int,drho_dT,           &
!$OMP                                  drho_dS,drxh_sum,kc,Hc,Tc,Sc,I_Hnew,gprime,     &
!$OMP                                  Rc,speed2_tot,Igl,Igu,lam0,lam,lam_it,dlam,     &
!$OMP                                  det,ddet,det_it,ddet_it)

  do j=js,je
    !   First merge very thin layers with the one above (or below if they are
    ! at the top).  This also transposes the row order so that columns can
    ! be worked upon one at a time.
    do i=is,ie ; htot(i) = 0.0 ; enddo
    do k=1,nz ; do i=is,ie ; htot(i) = htot(i) + h(i,j,k)*G%H_to_m ; enddo ; enddo

    do i=is,ie
      hmin(i) = htot(i)*min_h_frac ; kf(i) = 1 ; H_here(i) = 0.0
      HxT_here(i) = 0.0 ; HxS_here(i) = 0.0 ; HxR_here(i) = 0.0
    enddo
    if (use_EOS) then
      do k=1,nz ; do i=is,ie
        if ((H_here(i) > hmin(i)) .and. (h(i,j,k)*G%H_to_m > hmin(i))) then
          Hf(kf(i),i) = H_here(i)
          Tf(kf(i),i) = HxT_here(i) / H_here(i)
          Sf(kf(i),i) = HxS_here(i) / H_here(i)
          kf(i) = kf(i) + 1

          ! Start a new layer
          H_here(i) = h(i,j,k)*G%H_to_m
          HxT_here(i) = (h(i,j,k)*G%H_to_m)*T(i,j,k)
          HxS_here(i) = (h(i,j,k)*G%H_to_m)*S(i,j,k)
        else
          H_here(i) = H_here(i) + h(i,j,k)*G%H_to_m
          HxT_here(i) = HxT_here(i) + (h(i,j,k)*G%H_to_m)*T(i,j,k)
          HxS_here(i) = HxS_here(i) + (h(i,j,k)*G%H_to_m)*S(i,j,k)
        endif
      enddo ; enddo
      do i=is,ie ; if (H_here(i) > 0.0) then
        Hf(kf(i),i) = H_here(i)
        Tf(kf(i),i) = HxT_here(i) / H_here(i)
        Sf(kf(i),i) = HxS_here(i) / H_here(i)
      endif ; enddo
    else
      do k=1,nz ; do i=is,ie
        if ((H_here(i) > hmin(i)) .and. (h(i,j,k)*G%H_to_m > hmin(i))) then
          Hf(kf(i),i) = H_here(i) ; Rf(kf(i),i) = HxR_here(i) / H_here(i)
          kf(i) = kf(i) + 1

          ! Start a new layer
          H_here(i) = h(i,j,k)*G%H_to_m
          HxR_here(i) = (h(i,j,k)*G%H_to_m)*G%Rlay(k)
        else
          H_here(i) = H_here(i) + h(i,j,k)*G%H_to_m
          HxR_here(i) = HxR_here(i) + (h(i,j,k)*G%H_to_m)*G%Rlay(k)
        endif
      enddo ; enddo
      do i=is,ie ; if (H_here(i) > 0.0) then
        Hf(kf(i),i) = H_here(i) ; Rf(kf(i),i) = HxR_here(i) / H_here(i)
      endif ; enddo
    endif ! use_EOS?

    ! From this point, we can work on individual columns without causing memory
    ! to have page faults.
    do i=is,ie
      if (G%mask2dT(i,j) > 0.5) then

        lam = 1/(cg1(i,j)**2)
        
        ! Calculate drxh_sum
        if (use_EOS) then
          pres(1) = 0.0
          do k=2,kf(i)
            pres(k) = pres(k-1) + H_to_pres*Hf(k-1,i)
            T_int(k) = 0.5*(Tf(k,i)+Tf(k-1,i))
            S_int(k) = 0.5*(Sf(k,i)+Sf(k-1,i))
          enddo
          call calculate_density_derivs(T_int, S_int, pres, drho_dT, drho_dS, 2, &
                                        kf(i)-1, tv%eqn_of_state)

          ! Sum the reduced gravities to find out how small a density difference
          ! is negligibly small.
          drxh_sum = 0.0
          do k=2,kf(i)
            drxh_sum = drxh_sum + 0.5*(Hf(k-1,i)+Hf(k,i)) * &
                max(0.0,drho_dT(k)*(Tf(k,i)-Tf(k-1,i)) + &
                        drho_dS(k)*(Sf(k,i)-Sf(k-1,i)))
          enddo
        else
          drxh_sum = 0.0
          do k=2,kf(i)
            drxh_sum = drxh_sum + 0.5*(Hf(k-1,i)+Hf(k,i)) * &
                              max(0.0,Rf(k,i)-Rf(k-1,i))
          enddo
        endif ! use_EOS?
        
        !   Find gprime across each internal interface, taking care of convective
        ! instabilities by merging layers.
        if (drxh_sum >= 0.0) then
          ! Merge layers to eliminate convective instabilities or exceedingly
          ! small reduced gravities.
          if (use_EOS) then
            kc = 1
            Hc(1) = Hf(1,i) ; Tc(1) = Tf(1,i) ; Sc(1) = Sf(1,i)
            do k=2,kf(i)
              if ((drho_dT(k)*(Tf(k,i)-Tc(kc)) + drho_dS(k)*(Sf(k,i)-Sc(kc))) * &
                  (Hc(kc) + Hf(k,i)) < 2.0 * tol2*drxh_sum) then
                ! Merge this layer with the one above and backtrack.
                I_Hnew = 1.0 / (Hc(kc) + Hf(k,i))
                Tc(kc) = (Hc(kc)*Tc(kc) + Hf(k,i)*Tf(k,i)) * I_Hnew
                Sc(kc) = (Hc(kc)*Sc(kc) + Hf(k,i)*Sf(k,i)) * I_Hnew
                Hc(kc) = (Hc(kc) + Hf(k,i))
                ! Backtrack to remove any convective instabilities above...  Note
                ! that the tolerance is a factor of two larger, to avoid limit how
                ! far back we go.
                do k2=kc,2,-1
                  if ((drho_dT(k2)*(Tc(k2)-Tc(k2-1)) + drho_dS(k2)*(Sc(k2)-Sc(k2-1))) * &
                      (Hc(k2) + Hc(k2-1)) < tol2*drxh_sum) then
                    ! Merge the two bottommost layers.  At this point kc = k2.
                    I_Hnew = 1.0 / (Hc(kc) + Hc(kc-1))
                    Tc(kc-1) = (Hc(kc)*Tc(kc) + Hc(kc-1)*Tc(kc-1)) * I_Hnew
                    Sc(kc-1) = (Hc(kc)*Sc(kc) + Hc(kc-1)*Sc(kc-1)) * I_Hnew
                    Hc(kc-1) = (Hc(kc) + Hc(kc-1))
                    kc = kc - 1
                  else ; exit ; endif
                enddo
              else
                ! Add a new layer to the column.
                kc = kc + 1
                drho_dS(kc) = drho_dS(k) ; drho_dT(kc) = drho_dT(k)
                Tc(kc) = Tf(k,i) ; Sc(kc) = Sf(k,i) ; Hc(kc) = Hf(k,i) 
              endif
            enddo
            ! At this point there are kc layers and the gprimes should be positive.
            do k=2,kc ! Revisit this if non-Boussinesq.
              gprime(k) = g_Rho0 * (drho_dT(k)*(Tc(k)-Tc(k-1)) + &
                                    drho_dS(k)*(Sc(k)-Sc(k-1)))
            enddo
          else  ! .not.use_EOS
            ! Do the same with density directly...
            kc = 1
            Hc(1) = Hf(1,i) ; Rc(1) = Rf(1,i)
            do k=2,kf(i)
              if ((Rf(k,i) - Rc(kc)) * (Hc(kc) + Hf(k,i)) < 2.0*tol2*drxh_sum) then
                ! Merge this layer with the one above and backtrack.
                Rc(kc) = (Hc(kc)*Rc(kc) + Hf(k,i)*Rf(k,i)) / (Hc(kc) + Hf(k,i))
                Hc(kc) = (Hc(kc) + Hf(k,i))
                ! Backtrack to remove any convective instabilities above...  Note
                ! that the tolerance is a factor of two larger, to avoid limit how
                ! far back we go.
                do k2=kc,2,-1
                  if ((Rc(k2)-Rc(k2-1)) * (Hc(k2)+Hc(k2-1)) < tol2*drxh_sum) then
                    ! Merge the two bottommost layers.  At this point kc = k2.
                    Rc(kc-1) = (Hc(kc)*Rc(kc) + Hc(kc-1)*Rc(kc-1)) / (Hc(kc) + Hc(kc-1))
                    Hc(kc-1) = (Hc(kc) + Hc(kc-1))
                    kc = kc - 1
                  else ; exit ; endif
                enddo
              else
                ! Add a new layer to the column.
                kc = kc + 1
                Rc(kc) = Rf(k,i) ; Hc(kc) = Hf(k,i) 
              endif
            enddo
            ! At this point there are kc layers and the gprimes should be positive.
            do k=2,kc ! Revisit this if non-Boussinesq.
              gprime(k) = g_Rho0 * (Rc(k)-Rc(k-1))
            enddo
          endif  ! use_EOS?
          
          ! Construct and solve tridiagonal system
          if (kc >= 2) then
            z_int(1) = 0.0
            ! Calculate Igu, Igl, depth, and N2 at each interior interface
            do k=2,kc
              Igl(k) = 1.0/(gprime(k)*Hc(k)) ; Igu(k) = 1.0/(gprime(k)*Hc(k-1))
              z_int(k) = z_int(k-1) + Hc(k-1)
              N2(k) = gprime(k)/(0.5*(Hc(k)+Hc(k-1))
              lam_z(k) = lam*gprime(k)
            enddo
            z_int(kc+1) = z_int(kc)+Hc(kc)
            if (abs(z_int(kc+1)-htot)>1e-30) then
              call MOM_error(WARNING, "wave_structure: mismatch in total depths")
            endif
            z_depth(i,j,1:kc+1) = z_int(:)
            num_intfaces(i,j) = kc+1

            ! Populate interior rows of tridiagonal matrix; must multiply through by
            ! gprime to get tridiagonal matrix to the symmetrical form:
            ! [-1/H(k-1)]e(k-1) + [1/H(k-1)+1/H(k)-lam_z]e(k) + [-1/H(k)]e(k+1) = 0,
            ! where lam_z = lam*gprime is now a function of depth
            do k=3,kc-1
              row = k-1
              a_diag(row) = gprime(k)*(-Igu(k))
              b_diag(row) = gprime(k)*(Igu(k)+Igl(k)) - lam_z(k)
              c_diag(row) = gprime(k)*(-Igl(k))
            enddo
            ! Populate top row of tridiagonal matrix
            k=2 ; row = k-1
            a_diag(row) = 0.0
            b_diag(row) = gprime(k)*(Igu(k)+Igl(k)) - lam_z(k)
            c_diag(row) = gprime(k)*(-Igl(k))
            ! Populate bottom row of tridiagonal matrix
            k=kc ; row = k-1
            a_diag(row) = gprime(k)*(-Igu(k))
            b_diag(row) = gprime(k)*(Igu(k)+Igl(k)) - lam_z(k)
            c_diag(row) = 0.0
            
            ! Guess a vector shape to start with
            e_guess = cos(z_int(2:kc)/htot(i)*Pi)
            e_guess = e_guess/sqrt(sum(e_guess**2))
            ! Perform inverse iteration with tri-diag solver
            do itt=1,max_itt
              call tridiag_solver(a_diag,b_diag,c_diag,lam_z,e_guess,'TDMA_T',e_itt)
              e_guess = e_itt/sqrt(sum(e_itt**2))                           
            enddo ! itt-loop
            w_strct(i,j,2:kc) = e_guess
            w_strct(i,j,1) = 0.0    ! rigid lid at surface
            w_strct(i,j,kc+1) = 0.0 ! zero-flux at bottom
          endif  ! kc >= 2?
        endif ! drxh_sum >= 0?
      endif ! mask2dT > 0.5?
    enddo ! i-loop
  enddo ! j-loop
  
  do j=js,je
    do j=is,ie
      !!!calc u_strct!!!
    enddo ! i-loop
  enddo !j-loop
  
end subroutine wave_structure

subroutine tridiag_solver(a,b,c,h,y,method,x)
  real, dimension(:), intent(in)  :: a, b, c, h, y
  character(len=*), intent(in)    :: method
  real, dimension(:), intent(out) :: x

!    This subroutine solves a tri-diagonal system Ax=y using either the standard
! Thomas algorithim (TDMA_T) or its more stable variant that invokes the
! "Hallberg substitution" (TDMA_H).  
!
! Arguments: 
!  (in)      a - lower diagonal with first entry equal to zero
!  (in)      b - middle diagonal
!  (in)      c - upper diagonal with last entry equal to zero
!  (in)      h - vector of values that have already been added to b; used for 
!                systems of the form (e.g. layer thickness in vertical diffusion case):
!                [ -alpha(k-1/2) ]                       * e(k-1) +
!                [  alpha(k-1/2) + alpha(k+1/2) + h(k) ] * e(k)   +
!                [ -alpha(k+1/2) ]                       * e(k+1) = y(k)
!  (in)      y - vector of known values on right hand side
!  (out)     x - vector of unknown values to solve for

  integer :: n  = size(y)                 ! number of rows index in A matrix
  real, dimension(1:n) :: c_prime, yprime ! intermediate values for solver
  integer :: k                            ! row (e.g. interface) index
  
  if (method = 'TDMA_T') then
    ! Standard Thomas algoritim (4th variant)
    c_prime(:) = 0.0       ; y_prime(:) = 0.0
    c_prime(1) = c(1)/b(1) ; y_prime(1) = y(1)/b(1)
    ! Forward sweep
    do k=2,n-1
      c_prime(k) = c(k)/(b(k)-a(k)*c_prime(k-1))
    enddo
    do k=2,n
      y_prime(k) = (y(k)-a(k)*y_prime(k-1))/(b(k)-a(k)*c_prime(k-1))
    enddo
    x(n) = y_prime(n)
    ! Backward sweep
    do k=n-1,-1,1
      x(k) = y_prime(k)-c_prime(k)*x(k+1)
    enddo
  elseif (method = 'TDMA_H') then
    ! Standard Thomas algoritim (4th variant) w/ Hallberg substitution
  endif
  
end subroutine tridiag_solver

subroutine wave_structure_init(Time, G, param_file, diag, CS)
  type(time_type),             intent(in)    :: Time
  type(ocean_grid_type),       intent(in)    :: G
  type(param_file_type),       intent(in)    :: param_file
  type(diag_ctrl), target,     intent(inout) :: diag
  type(wave_structure_CS),     pointer       :: CS
! Arguments: Time - The current model time.
!  (in)      G - The ocean's grid structure.
!  (in)      param_file - A structure indicating the open file to parse for
!                         model parameter values.
!  (in)      diag - A structure that is used to regulate diagnostic output.
!  (in/out)  CS - A pointer that is set to point to the control structure
!                  for this module
! This include declares and sets the variable "version".
#include "version_variable.h"
  character(len=40)  :: mod = "MOM_wave_structure"  ! This module's name.

  if (associated(CS)) then
    call MOM_error(WARNING, "wave_structure_init called with an "// &
                            "associated control structure.")
    return
  else ; allocate(CS) ; endif

  CS%diag => diag

  ! Write all relevant parameters to the model log.
  call log_version(param_file, mod, version, "")

end subroutine wave_structure_init

end module MOM_wave_structure
